#!/usr/bin/python2.7
from datetime import datetime
from time import gmtime, strftime # time as returned by gmtime(secs) or localtime() to a string as specified by the format argument
import time # to convert am/pm time to 24h
import os #The OS module in Python provides a way of using operating system dependent functionality
import gzip#the gzip module provides a file-like interface to GNU zip files, using zlib to compress and uncompress the data.
import commands# depreated in py3.0 The commands module contains wrapper functions for os.popen() which take a system command as a string and return any output generated by the command and, optionally, the exit status.
import sys#This module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter
from email.mime.text import MIMEText
import subprocess
import socket
import smtplib
import tarfile
import argparse
import logging
import shutil
import base64
import requests

logging.basicConfig(format='%(asctime)s %(message)s', datefmt='%m/%d/%Y %I:%M:%S %p',filemode='a',filename = 'backup.log',level=logging.DEBUG)
logger = logging.getLogger(__name__)

class args_exception(Exception):
    def __init__(self, code):
        self.code = code
    def __str__(self):
        return repr(self)

class Backup_exception(Exception):
    def __init__(self, code):
        self.code = code
    def __str__(self):
        return repr(self)

class suberr_Backup_exception(Exception):
    def __init__(self, code):
        self.code = code
    def __str__(self):
        return repr(self)

class Compress_exception(Exception):
    def __init__(self, code):
        self.code = code
    def __str__(self):
        return repr(self)

class Cleanup_exception(Exception):
    def __init__(self, code):
        self.code = code
    def __str__(self):
        return repr(self)

def is_dir(path):
    """Checks if a path is an actual directory"""
    if not os.path.isdir(path):
        msg = "{0} is not a directory".format(path)
        raise argparse.ArgumentTypeError(msg)
        logging.info(msg)
    else:
        return path

def get_args():
        parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter)
        parser.add_argument('--backup-name', type=str, required=True, help='Backup file name')
        parser.add_argument('--backup-directory', type=is_dir, required=True, help='Target directory for the backup')
        parser.add_argument('--age', type=int, help='Delete backup files older than the specified amount of days')
        try:
           return parser.parse_args()
        except SystemExit:
            error_code = "Bad argument error"
            raise args_exception(error_code)
            logger.exception('Error while passing args')

def SendAlert(ErrorMessage):
    try:
        _body = ErrorMessage
        msg = MIMEText(_body)
        _from = "EMAIL"
        _to = "EMAIL"
        _subject = "Test couchBase  backup failed: {0}".format(socket.gethostname())
        msg["From"] = _from
        msg["To"] = _to
        msg["Subject"] = _subject
        logging.info ("email body is  {0} ".format(_body))
        if (_body != ""):
           sender = smtplib.SMTP("localhost")
           logging.info ("sender is  {0} ".format(sender))
           sender.sendmail([_from], _to, msg.as_string())
           sender.quit()
    except Exception as err:
        logger.exception('Error while sending email')
        raise err

def takebackup(dir):
    try:
        logging.info('Backup started')
        logging.info ("backup-name {0} ".format(dir))
        cmds=["/opt/couchbase/bin/cbbackup","http://localhost:PORTNUMBER",dir,"-m","full","-u","USERNAME","-p",base64.b64decode("ABCXYZ"),"-b","BUCKETNAME"]
        run = subprocess.check_call(cmds, stdin=None, shell=False)
        logger.info('Backup completed')
    except subprocess.CalledProcessError as err:
            error_code = err
            raise suberr_Backup_exception(error_code)
            logger.exception('Error in takebackup')
    except (subprocess.CalledProcessError,IOError, OSError, SystemError)  as err:
            error_code = err
            raise Backup_exception(error_code)
            logger.exception('Error in takebackup')


def compress_backup(dump_path, backupname):
    try:
       logging.info('Compress_backup started')
       bkp_compress=(os.path.splitext(backupname)[0])+'.tar.gz'
       tar = tarfile.open(bkp_compress, "w")
       for name in [backupname]:
         tar.add(name,arcname=backupname)
         tar.close()
         logging.info("Compress_backup folder  {0} ".format(backupname))
         logging.info('Compress_backup completed')
         if backupname!= dump_path:
             shutil.rmtree(backupname)
             logging.info('Deleted backup folder after creating .tar.gz backup folder')
    except (IOError, OSError, SystemError)  as strerr:
        error_code = strerr
        raise Compress_exception(error_code)
        logger.exception('Error in compress_backup')

def cleanup_old_backupfiles(dump_path, age):
    logging.info('Check old backup files')
    if age is not None:
        now = time.time()
        for bf in os.listdir(dump_path):
            f = os.path.join(dump_path, bf)
            if os.stat(f).st_mtime < now - age * 86400 and f.endswith(".tar.gz") and os.path.isfile(f):
                try:
                    logging.info('Cleaning up old backup files started')
                    os.remove(f)
                    logging.info('Cleaning up old backup files completed')
                except SystemError as i:
                    error_code = i
                    raise Cleanup_exception(error_code)
                    logger.exception('Error in cleanup_old_backupfiles')


def main():
    try:
       args = get_args()
       DATE = time.strftime('%m%d%Y-%H%M%S')
       backupname = args.backup_directory +"/"+ args.backup_name + "-" +DATE
       fullpath = os.path.join(args.backup_directory, backupname)
       dump_path = args.backup_directory
       start_time = datetime.now()
       end_time = datetime.now()
       logging.info('Starting the job...')
       takebackup(fullpath)
       compress_backup(args.backup_directory, backupname)
       cleanup_old_backupfiles(args.backup_directory, args.age)
       end_time = datetime.now()
       executiontime = ("Total job execution time is {0} ".format(end_time - start_time))
       logging.info(executiontime)
       logging.info('Job completed...')

    except args_exception as e :
        ErrorMessage = ("Error -  Bad argument" )
        SendAlert(ErrorMessage)

    except Backup_exception as e :
        ErrorMessage = ("Error -  Backup db : {}".format(e.code ))
        SendAlert(ErrorMessage)

    except suberr_Backup_exception as e :
        ErrorMessage = ("Error - Backup returned non-zero exit status 1")
        SendAlert(ErrorMessage)

    except Compress_exception as e :
        ErrorMessage = ("Error - Compressing backup : {}".format(e.code))
        SendAlert(ErrorMessage)

    except Cleanup_exception as e :
        ErrorMessage = ("Error - Cleaning up old backup files : {}".format(e.code))
        SendAlert(ErrorMessage)

if __name__ == "__main__":
    main()
